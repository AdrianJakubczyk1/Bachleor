
\chapter{Podsumowanie projektu i wnioski}
W ramach zrealizowanego projektu stworzono funkcjonalną platformę webową służącą do udostępniania materiałów edukacyjnych, zarządzania kursami oraz interakcji między studentami a nauczycielami. Aplikacja została zaprojektowana i wykonana w oparciu o nowoczesny stos technologiczny (Spring Boot 3, Java 23, Thymeleaf, Bootstrap) z nietypowym rozwiązaniem w zakresie przechowywania danych użyciem bazy danych w pamięci Hazelcast zamiast tradycyjnej bazy relacyjnej. W toku implementacji osiągnięto założone cele funkcjonalne: użytkownicy mogą się rejestrować i logować, nauczyciele tworzyć kursy i materiały, studenci zapisywać na zajęcia i przesyłać zadania, a administratorzy nadzorować całość systemu i analizować statystyki. Rezultatem prac jest prototyp platformy e-learningowej o prostej, przejrzystej obsłudze, który może stanowić podstawę do dalszego rozwoju lub wdrożenia na potrzeby uczelni czy kursów online. W trakcie testów potwierdzono poprawność i stabilność działania aplikacji, co oznacza, że przyjęte decyzje architektoniczne i technologiczne sprawdziły się w praktyce. Na zakończenie, warto dokonać analizy kluczowej decyzji projektowej dotyczącej bazy danych: zastosowania bazy danych w pamięci zamiast klasycznej bazy relacyjnej. Poniżej zebrano główne zalety i wady takiego rozwiązania zaobserwowane w kontekście tego projektu: \textbf{Zalety wykorzystania bazy in-memory (Hazelcast) w porównaniu z relacyjną bazą danych:}
\begin{itemize}
\item \textbf{Wysoka wydajność i niskie opóźnienia dostępu do danych} – wszystkie dane przechowywane są w pamięci RAM, dzięki czemu odczyty i zapisy odbywają się bez opóźnień związanych z operacjami dyskowymi. W testach aplikacja z Hazelcastem cechowała się bardzo krótkimi czasami odpowiedzi, co pozytywnie wpływa na doświadczenie użytkowników.
\item \textbf{Prostsza skalowalność pozioma} – Hazelcast z natury wspiera klasteryzację i replikację danych między węzłami. Dodanie kolejnego serwera aplikacji automatycznie zwiększa dostępną pamięć i moc obliczeniową klastra Hazelcast, co umożliwia obsługę większej liczby użytkowników bez skomplikowanej konfiguracji klastrów baz danych.
\item \textbf{Łatwość wdrożenia i brak zależności od zewnętrznej infrastruktury DBMS} – aplikacja nie wymaga instalacji i administrowania osobnym serwerem bazy danych (np. MySQL/PostgreSQL). Hazelcast działa wbudowany w aplikację, co upraszcza proces uruchomienia platformy na nowym środowisku  wystarczy uruchomić aplikację Java, a magazyn danych inicjuje się samoczynnie.
\item \textbf{Wsparcie dla dodatkowych funkcjonalności} – Hazelcast to nie tylko magazyn klucz-wartość. Udostępnia wiele zaawansowanych struktur i usług (kolejki, mechanizmy locków, strumieniowe przetwarzanie danych itp.). W projekcie wykorzystano np. \texttt{FlakeIdGenerator} do generacji identyfikatorów czy \texttt{IMap} z indeksami do szybkiego wyszukiwania. Te mechanizmy w pewnych scenariuszach mogą upraszczać implementację (omijając konieczność pisania złożonych zapytań SQL).
\end{itemize} \textbf{Wady i ograniczenia podejścia in-memory względem tradycyjnej bazy relacyjnej:}
\begin{itemize}
\item \textbf{Brak trwałości danych (domyślnie)} – podstawowym minusem jest ulotność danych. O ile bazy relacyjne zapewniają domyślnie trwały zapis na dysku , o tyle Hazelcast przechowuje dane w pamięci awaria lub restart skutkuje utratą danych, chyba że zastosuje się dodatkowe mechanizmy (np. zapis  na dysku). W kontekście aplikacji edukacyjnej utrata danych mogłaby być krytyczna (np. zniknięcie informacji o kontach czy zadaniach), więc w środowisku produkcyjnym należałoby tę kwestię rozwiązać przed wdrożeniem.
\item \textbf{Zużycie pamięci operacyjnej} – przechowywanie kompletnej bazy danych w RAM może być kosztowne pamięciowo, zwłaszcza przy dużej skali danych (tysiące użytkowników, setki tysięcy rekordów). Pamięć jest droższym zasobem niż przestrzeń dyskowa, zatem aplikacja oparta wyłącznie na Hazelcast może wymagać serwerów z dużą ilością RAM, aby pomieścić wszystkie dane. W przeciwnym razie konieczne byłoby ograniczanie zakresu danych (np. archiwizacja starszych informacji poza Hazelcastem).
\item \textbf{Ograniczone możliwości zapytań} – relacyjne bazy danych i język SQL oferują bardzo bogate możliwości zapytań (łączenie tabel, agregacje, złożone filtrowanie, podzapytania itp.). W Hazelcast również istnieje możliwość wykonywania zapytań (nawet zbliżonych do SQL przy użyciu Hazelcast SQL), jednak nie jest to tak elastyczne i wydajne przy bardzo złożonych zapytaniach jak w wyspecjalizowanych silnikach SQL. W moim projekcie model danych był stosunkowo prosty (brak skomplikowanych relacji), więc ta wada nie była odczuwalna, ale w bardziej złożonym domenowo systemie mogłaby stanowić problem.
\item \textbf{mniej popularne rozwiązanie} – rozwiązania oparte o relacyjne bazy danych są dobrze znane programistom i administratorom, istnieje wiele materiałów, narzędzi i dobrych praktyk. Hazelcast, będący specyficzną bazą danych w pamięci, może wymagać od zespołu pewnej krzywej nauki oraz ostrożności w użyciu (np. konfiguracja klastrów).
\end{itemize} Podsumowując, zastosowanie Hazelcast w projekcie przyniosło wymierne korzyści w zakresie wydajności i uproszczenia warstwy dostępu do danych, co było istotne z punktu widzenia prototypowania i demonstracji działania platformy. Z drugiej strony, zdano sobie sprawę z ograniczeń takiego podejścia w szczególności kwestii trwałości danych co należałoby adresować przed użyciem systemu w środowisku produkcyjnym. Możliwym kierunkiem rozwoju byłoby wprowadzenie hybrydowej architektury, gdzie Hazelcast działałby jako warstwa cache i mechanizm szybkiego dostępu (np. do sesji i często czytanych danych), natomiast ostateczna trwała kopia danych byłaby przechowywana w relacyjnej bazie danych w sposób asynchroniczny. Projekt zaliczyć można do udanych – zrealizował zakładane funkcjonalności, a przy tym stanowi ciekawy przykład wykorzystania nowatorskich rozwiązań w aplikacjach webowych. Wnioski płynące z prac nad nim mogą być cenne przy podejmowaniu decyzji architektonicznych w przyszłych systemach: wybór bazy danych powinien być podyktowany konkretnymi wymaganiami i ograniczeniami projektu (wydajność vs. trwałość, prostota vs. możliwości zapytań).